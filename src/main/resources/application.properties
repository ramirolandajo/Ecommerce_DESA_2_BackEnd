# Nombre de la aplicacion
spring.application.name=Ecommerce

# Puerto del microservicio
server.port=${SERVER_PORT:8081}

# Perfil por defecto (puede overridearse por SPRING_PROFILES_ACTIVE)
#spring.profiles.active=${SPRING_PROFILES_ACTIVE:dev}

# =====================
# Datasource - MySQL AWS (unica conexion activa)
# =====================
spring.datasource.url=jdbc:mysql://${SPRING_DATASOURCE_URL}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD}

# Deshabilitar completamente H2 (consola y BD embebida)
spring.h2.console.enabled=false
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration
spring.datasource.embedded-database-connection=none

# JPA/Hibernate
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=true

# No ejecutar scripts SQL en el arranque (evita correr data.sql en prod)
spring.jpa.defer-datasource-initialization=false
spring.sql.init.mode=never

# SMTP
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=${SPRING_MAIL_USERNAME}
spring.mail.password=${SPRING_MAIL_PASSWORD}
spring.mail.properties.mail.smtp.ssl.trust=smtp.gmail.com
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true

# Core API (API de Comunicacion que enruta y publica en Kafka)
# Por defecto en desarrollo apuntamos al mock local en http://localhost:8086
core.api.url=${CORE_API_URL:http://localhost:8086}

# CloudFront settings
server.servlet.context-path=/api
server.forward-headers-strategy=framework

# Kafka MiddleWare
communication.intermediary.url=${KAFKA_MIDDLEWARE_URL:http://localhost:8090}

# JWT secret (configurar via entorno en produccion)
jwt.secret=${JWT_SECRET}

# Keycloak (Client Credentials - Opcion 1 del realm)
keycloak.token.url=${KEYCLOAK_TOKEN_URL:http://localhost:8080/realms/ecommerce/protocol/openid-connect/token}
keycloak.client-id=ventas-app
keycloak.client-secret=${KEYCLOAK_CLIENT_SECRET}
# Keycloak: desactivar refresh programado del token (evita reintentos constantes)
keycloak.refresh.enabled=false

# =====================
# Kafka - Ventas Consumer
# =====================
ventas.kafka.enabled=true
ventas.kafka.topic=ventas
ventas.kafka.concurrency=3
# Deshabilitar listener de ventas por defecto (solo escuchar inventario)
ventas.kafka.listen-ventas=false

spring.kafka.bootstrap-servers=${KAFKA_BOOTSTRAP:localhost:9092}
spring.kafka.consumer.group-id=ventas-ms
spring.kafka.consumer.auto-offset-reset=earliest

# --- Force SASL on the AdminClient (used at startup) ---
spring.kafka.admin.properties.security.protocol=SASL_PLAINTEXT
spring.kafka.admin.properties.sasl.mechanism=SCRAM-SHA-512
spring.kafka.admin.properties.sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username="${KAFKA_USERNAME}" password="${KAFKA_PASSWORD}";

# --- Force SASL on the Producer ---
spring.kafka.producer.properties.security.protocol=SASL_PLAINTEXT
spring.kafka.producer.properties.sasl.mechanism=SCRAM-SHA-512
spring.kafka.producer.properties.sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username="${KAFKA_USERNAME}" password="${KAFKA_PASSWORD}";

# --- Force SASL on the Consumer ---
spring.kafka.consumer.properties.security.protocol=SASL_PLAINTEXT
spring.kafka.consumer.properties.sasl.mechanism=SCRAM-SHA-512
spring.kafka.consumer.properties.sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username="${KAFKA_USERNAME}" password="${KAFKA_PASSWORD}";

spring.kafka.properties.security.protocol=SASL_PLAINTEXT
spring.kafka.properties.sasl.mechanism=SCRAM-SHA-512
spring.kafka.properties.sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username="${KAFKA_USERNAME}" password="${KAFKA_PASSWORD}";
# Logging para el consumidor de ventas
logging.level.ar.edu.uade.ecommerce.ventas=INFO

# Reintentos controlados y DLQ (opcional)
ventas.kafka.error.maxAttempts=3
ventas.kafka.error.backoff.ms=500
ventas.kafka.dlq.enabled=false
ventas.kafka.dlq.topicSuffix=.dlq

# =====================
# Kafka - Inventario Consumer (para que Ventas escuche inventario.events)
# =====================
# Consumir SOLO del topico 'inventario' por defecto
inventario.kafka.topic=inventario
inventario.kafka.concurrency=1
inventario.kafka.listen-inventario=true

# Evitar fallo si el topico no existe al arrancar (util en desarrollo)
spring.kafka.listener.missing-topics-fatal=false

# =====================
# Retry de eventos consumidos (scheduler cada 6 horas)
# =====================
ventas.retry.enabled=true
# Corre cada 6 horas por defecto
ventas.retry.cron=0 0 */6 * * *
ventas.retry.maxAttempts=5
ventas.retry.cooldown.minutes=30
ventas.retry.batchSize=100

# Logging de retry
logging.level.ar.edu.uade.ecommerce.ventas.VentasInventoryRetryScheduler=INFO

# =====================
# ACK al middleware por eventId
# =====================
communication.intermediary.ack.enabled=true
communication.intermediary.ack.path=/events/{eventId}/ack
communication.intermediary.ack.method=POST
