# Nombre de la aplicación
spring.application.name=Ecommerce

# Puerto del microservicio
server.port=8081

# Perfil por defecto para desarrollo (usa H2). Se puede overridear con la variable de entorno SPRING_PROFILES_ACTIVE
spring.profiles.active=${SPRING_PROFILES_ACTIVE:dev}

# Base de datos (MySQL) - Comentada para evitar conexión al no usar el profile correspondiente
# spring.datasource.url=jdbc:mysql://d2-develop.ct6ouwkcg80y.sa-east-1.rds.amazonaws.com/ecommerce_dev
# spring.datasource.username=admin
# spring.datasource.password=Desarrollo2%
# spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
# spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.format_sql=true

# SMTP
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=enzoandreaasplanatti@gmail.com
spring.mail.password=mclsdtbglujoeexn
spring.mail.properties.mail.smtp.ssl.trust=smtp.gmail.com
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true

# Core API (API de Comunicación que enruta y publica en Kafka)
# Por defecto en desarrollo apuntamos al mock local en http://localhost:8086
core.api.url=${CORE_API_URL:http://localhost:8086}

<<<<<<< Updated upstream
# CloudFront settings
server.servlet.context-path=/api
server.forward-headers-strategy=framework

#Kafka MiddleWare
communication.intermediary.url=${KAFKA_MIDDLEWARE_URL}
=======
#Comunicacion con el módulo de intermediario antes de llegar al core -> COMMUNICATION_INTERMEDIARY_API_URL
communication.intermediary.url=${COMMUNICATION_INTERMEDIARY_API_URL:http://localhost:8090}


# JWT secret (development default). In production provide JWT_SECRET env var or configure a secure secret manager.
jwt.secret=${JWT_SECRET:3Ikq6JD3SQDuc70EhGDWIwdbXG7fB0b3axVGnjEqLkWX9Kw7Niqc0O2LaJVuIkLuBwMykmO80KFb5mUIwdHzZg==}

# Keycloak (Client Credentials - Opción 1 del realm)
keycloak.token.url=http://localhost:8080/realms/ecommerce/protocol/openid-connect/token
keycloak.client-id=ecommerce-app
keycloak.client-secret=8QHZseZkNWmhI7p2jFA5MbGF4ZdiS9xu
# Keycloak: desactivar refresh programado del token (evita reintentos constantes)
keycloak.refresh.enabled=false

# =====================
# Kafka - Ventas Consumer
# =====================
ventas.kafka.enabled=${VENTAS_KAFKA_ENABLED:true}
ventas.kafka.topic=${VENTAS_KAFKA_TOPIC:ventas.events}
ventas.kafka.concurrency=${VENTAS_KAFKA_CONCURRENCY:3}
# Deshabilitar listener de ventas por defecto (solo escuchar inventario)
ventas.kafka.listen-ventas=${VENTAS_KAFKA_LISTEN_VENTAS:false}

spring.kafka.bootstrap-servers=${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
spring.kafka.consumer.group-id=${KAFKA_CONSUMER_GROUP:ventas-ms}
spring.kafka.consumer.auto-offset-reset=${KAFKA_AUTO_OFFSET_RESET:earliest}

# Logging para el consumidor de ventas
logging.level.ar.edu.uade.ecommerce.ventas=INFO

# Reintentos controlados y DLQ (opcional)
ventas.kafka.error.maxAttempts=${VENTAS_KAFKA_ERROR_MAX_ATTEMPTS:3}
ventas.kafka.error.backoff.ms=${VENTAS_KAFKA_ERROR_BACKOFF_MS:500}
ventas.kafka.dlq.enabled=${VENTAS_KAFKA_DLQ_ENABLED:false}
ventas.kafka.dlq.topicSuffix=${VENTAS_KAFKA_DLQ_TOPIC_SUFFIX:.dlq}

# =====================
# Kafka - Inventario Consumer (para que Ventas escuche inventario.events)
# =====================
# Consumir SOLO del tópico 'inventario' por defecto
inventario.kafka.topic=${INVENTARIO_KAFKA_TOPIC:inventario}
# Bajar concurrencia a 1 para evitar bucles innecesarios en dev
inventario.kafka.concurrency=${INVENTARIO_KAFKA_CONCURRENCY:1}
# Habilitar listener de inventario por defecto
inventario.kafka.listen-inventario=${INVENTARIO_KAFKA_LISTEN_INVENTARIO:true}

# Evitar fallo si el tópico no existe al arrancar (útil en desarrollo)
spring.kafka.listener.missing-topics-fatal=false

# =====================
# Retry de eventos consumidos (scheduler cada 6 horas)
# =====================
ventas.retry.enabled=${VENTAS_RETRY_ENABLED:true}
# Corre cada 6 horas por defecto
ventas.retry.cron=${VENTAS_RETRY_CRON:0 0 */6 * * *}
ventas.retry.maxAttempts=${VENTAS_RETRY_MAX_ATTEMPTS:5}
ventas.retry.cooldown.minutes=${VENTAS_RETRY_COOLDOWN_MINUTES:30}
ventas.retry.batchSize=${VENTAS_RETRY_BATCH_SIZE:100}

# Logging de retry
logging.level.ar.edu.uade.ecommerce.ventas.VentasInventoryRetryScheduler=INFO

# =====================
# ACK al middleware por eventId
# =====================
communication.intermediary.ack.enabled=${COMMUNICATION_ACK_ENABLED:true}
communication.intermediary.ack.path=${COMMUNICATION_ACK_PATH:/events/{eventId}/ack}
communication.intermediary.ack.method=${COMMUNICATION_ACK_METHOD:POST}
>>>>>>> Stashed changes
