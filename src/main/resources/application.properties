# Nombre de la aplicación
spring.application.name=${SPRING_APP_NAME:Ecommerce}

# Puerto del microservicio
server.port=${SERVER_PORT:8081}

# Perfil por defecto (puede overridearse por SPRING_PROFILES_ACTIVE)
#spring.profiles.active=${SPRING_PROFILES_ACTIVE:dev}

# =====================
# Datasource - MySQL AWS (única conexión activa)
# =====================
spring.datasource.url=${SPRING_DATASOURCE_URL}
spring.datasource.driver-class-name=${SPRING_DATASOURCE_DRIVER}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD}

# Deshabilitar completamente H2 (consola y BD embebida)
spring.h2.console.enabled=false
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration
spring.datasource.embedded-database-connection=none

# JPA/Hibernate
spring.jpa.hibernate.ddl-auto=${SPRING_JPA_HIBERNATE_DDL_AUTO:update}
spring.jpa.show-sql=${SPRING_JPA_SHOW_SQL:true}
spring.jpa.properties.hibernate.format_sql=${HIBERNATE_FORMAT_SQL:true}

# No ejecutar scripts SQL en el arranque (evita correr data.sql en prod)
spring.jpa.defer-datasource-initialization=false
spring.sql.init.mode=never

# SMTP
spring.mail.host=${SPRING_MAIL_HOST:smtp.gmail.com}
spring.mail.port=${SPRING_MAIL_PORT:587}
spring.mail.username=${SPRING_MAIL_USERNAME}
spring.mail.password=${SPRING_MAIL_PASSWORD}
spring.mail.properties.mail.smtp.ssl.trust=${SPRING_MAIL_SSL_TRUST:smtp.gmail.com}
spring.mail.properties.mail.smtp.auth=${SPRING_MAIL_SMTP_AUTH:true}
spring.mail.properties.mail.smtp.starttls.enable=${SPRING_MAIL_STARTTLS_ENABLE:true}
spring.mail.properties.mail.smtp.starttls.required=${SPRING_MAIL_STARTTLS_REQUIRED:true}

# Core API (API de Comunicación que enruta y publica en Kafka)
# Por defecto en desarrollo apuntamos al mock local en http://localhost:8086
core.api.url=${CORE_API_URL:http://localhost:8086}

# CloudFront settings
server.servlet.context-path=${SERVER_SERVLET_CONTEXT_PATH:/api}
server.forward-headers-strategy=${SERVER_FORWARD_HEADERS_STRATEGY:framework}

# Kafka MiddleWare
communication.intermediary.url=${KAFKA_MIDDLEWARE_URL:http://localhost:8090}

# JWT secret (configurar vía entorno en producción)
jwt.secret=${JWT_SECRET}

# Keycloak (Client Credentials - Opción 1 del realm)
keycloak.token.url=${KEYCLOAK_TOKEN_URL:http://localhost:8080/realms/ecommerce/protocol/openid-connect/token}
keycloak.client-id=${KEYCLOAK_CLIENT_ID:ecommerce-app}
keycloak.client-secret=${KEYCLOAK_CLIENT_SECRET}
# Keycloak: desactivar refresh programado del token (evita reintentos constantes)
keycloak.refresh.enabled=${KEYCLOAK_REFRESH_ENABLED:false}

# =====================
# Kafka - Ventas Consumer
# =====================
ventas.kafka.enabled=${VENTAS_KAFKA_ENABLED:true}
ventas.kafka.topic=${VENTAS_KAFKA_TOPIC:ventas.events}
ventas.kafka.concurrency=${VENTAS_KAFKA_CONCURRENCY:3}
# Deshabilitar listener de ventas por defecto (solo escuchar inventario)
ventas.kafka.listen-ventas=${VENTAS_KAFKA_LISTEN_VENTAS:false}

spring.kafka.bootstrap-servers=${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
spring.kafka.consumer.group-id=${KAFKA_CONSUMER_GROUP:ventas-ms}
spring.kafka.consumer.auto-offset-reset=${KAFKA_AUTO_OFFSET_RESET:earliest}

# Logging para el consumidor de ventas
logging.level.ar.edu.uade.ecommerce.ventas=${LOG_LEVEL_AR_EDU_UADE_ECOMMERCE_VENTAS:INFO}

# Reintentos controlados y DLQ (opcional)
ventas.kafka.error.maxAttempts=${VENTAS_KAFKA_ERROR_MAX_ATTEMPTS:3}
ventas.kafka.error.backoff.ms=${VENTAS_KAFKA_ERROR_BACKOFF_MS:500}
ventas.kafka.dlq.enabled=${VENTAS_KAFKA_DLQ_ENABLED:false}
ventas.kafka.dlq.topicSuffix=${VENTAS_KAFKA_DLQ_TOPIC_SUFFIX:.dlq}

# =====================
# Kafka - Inventario Consumer (para que Ventas escuche inventario.events)
# =====================
# Consumir SOLO del tópico 'inventario' por defecto
inventario.kafka.topic=${INVENTARIO_KAFKA_TOPIC:inventario}
# Bajar concurrencia a 1 para evitar bucles innecesarios en dev
inventario.kafka.concurrency=${INVENTARIO_KAFKA_CONCURRENCY:1}
# Habilitar listener de inventario por defecto
inventario.kafka.listen-inventario=${INVENTARIO_KAFKA_LISTEN_INVENTARIO:true}

# Evitar fallo si el tópico no existe al arrancar (útil en desarrollo)
spring.kafka.listener.missing-topics-fatal=${SPRING_KAFKA_LISTENER_MISSING_TOPICS_FATAL:false}

# =====================
# Retry de eventos consumidos (scheduler cada 6 horas)
# =====================
ventas.retry.enabled=${VENTAS_RETRY_ENABLED:true}
# Corre cada 6 horas por defecto
ventas.retry.cron=${VENTAS_RETRY_CRON:0 0 */6 * * *}
ventas.retry.maxAttempts=${VENTAS_RETRY_MAX_ATTEMPTS:5}
ventas.retry.cooldown.minutes=${VENTAS_RETRY_COOLDOWN_MINUTES:30}
ventas.retry.batchSize=${VENTAS_RETRY_BATCH_SIZE:100}

# Logging de retry
logging.level.ar.edu.uade.ecommerce.ventas.VentasInventoryRetryScheduler=${LOG_LEVEL_VENTAS_RETRY_SCHEDULER:INFO}

# =====================
# ACK al middleware por eventId
# =====================
communication.intermediary.ack.enabled=${COMMUNICATION_ACK_ENABLED:true}
communication.intermediary.ack.path=${COMMUNICATION_ACK_PATH:/events/{eventId}/ack}
communication.intermediary.ack.method=${COMMUNICATION_ACK_METHOD:POST}